# Tool System Implementation (RFC-AGT-002)

This directory contains the implementation of the Tool Definition & Execution Framework as specified in RFC-AGT-002. The system enables ReAct agents to use tools like `code_search` and `read_file` to interact with the codebase.

## Architecture Overview

The tool system follows a modular architecture:

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Client        │    │   Agent Handler  │    │  Tool Executor  │
│                 │    │                  │    │                 │
│ 1. Send Query   │───▶│ 2. ReAct Step    │    │                 │
│ 4. Execute Tool │───▶│ 3. Propose Action│───▶│ 5. Execute Tool │
│ 7. Send Obs     │───▶│ 6. Return Action │◀───│ 8. Return Obs   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

## Components

### 1. Tool Implementations

#### `codeSearchTool.ts`
- **Purpose**: Searches codebase for relevant code snippets using vector similarity
- **Function**: `executeCodeSearch(env, projectId, args, userApiKeys, embeddingModelConfig)`
- **Dependencies**: `retrievalService.performVectorSearch`
- **Output**: Formatted search results with file paths, line numbers, and code snippets

#### `readFileTool.ts`
- **Purpose**: Reads complete file content from R2 storage
- **Function**: `executeReadFile(env, projectId, args)`
- **Dependencies**: R2 bucket access
- **Output**: Formatted file content with syntax highlighting

### 2. Tool Executor (`toolExecutor.ts`)

Central dispatcher that:
- Validates tool arguments
- Routes tool calls to appropriate implementations
- Handles errors and returns standardized responses
- Generates tool manifest for LLM prompts

### 3. API Endpoints

#### `POST /api/agent/react_step`
- Existing endpoint for ReAct agent reasoning
- Now includes `available_tools_prompt_segment` in request
- Returns `action_details` when tool use is proposed

#### `POST /api/agent/execute_action` (NEW)
- Executes tools proposed by the agent
- Validates tool execution requests
- Returns tool observations for next ReAct iteration

## Tool Manifest

The system generates a dynamic tool manifest that describes available tools to the LLM:

```
You have access to the following tools:

1. **code_search(query: string)**: Searches the codebase for code snippets relevant to the query.
   - Use this when you need to find specific functions, classes, patterns
   - Example: code_search(query="user authentication functions")

2. **read_file(file_path: string)**: Reads the full content of the specified file.
   - Use this when you need to see the complete implementation
   - Example: read_file(file_path="src/models/user.py")

To use a tool, output on a new line:
Action: tool_name(param1="value1", param2="value2")
```

## Client-Mediated Workflow

The system uses a client-mediated approach where the client orchestrates the ReAct loop:

1. **Initial Query**: Client sends user query to `/api/agent/react_step`
2. **Agent Reasoning**: Agent analyzes query and proposes tool action
3. **Tool Execution**: Client sends action to `/api/agent/execute_action`
4. **Observation**: Tool executes and returns observation
5. **Next Iteration**: Client sends observation back to `/api/agent/react_step`
6. **Final Response**: Agent provides answer based on tool observations

## Example Usage

### Step 1: Initial ReAct Request
```typescript
POST /api/agent/react_step
{
  "project_id": "uuid",
  "session_id": "uuid", 
  "user_query": "How does authentication work?",
  "conversation_history": [],
  "available_tools_prompt_segment": "...", // Generated by generateToolManifestPrompt()
  "llm_config": { ... },
  "user_api_keys": { "llmKey": "..." },
  "max_iterations_left": 5
}
```

### Step 2: Agent Proposes Tool Action
```typescript
{
  "session_id": "uuid",
  "thought": "I need to search for authentication code.",
  "action_details": {
    "tool_name": "code_search",
    "tool_args": { "query": "authentication login" },
    "raw_action_string": "Action: code_search(query=\"authentication login\")"
  },
  "status": "action_proposed"
}
```

### Step 3: Tool Execution Request
```typescript
POST /api/agent/execute_action
{
  "project_id": "uuid",
  "session_id": "uuid",
  "tool_name": "code_search", 
  "tool_args": { "query": "authentication login" },
  "user_api_keys": { "embeddingKey": "..." },
  "embedding_model_config": { ... }
}
```

### Step 4: Tool Observation Response
```typescript
{
  "session_id": "uuid",
  "tool_name": "code_search",
  "observation": "Found 2 code snippets for query: \"authentication login\"\n\n1. **src/auth.ts** (Lines 15-30, Score: 0.892)\n```typescript\nexport function authenticate(token: string) { ... }\n```",
  "is_error": false,
  "execution_time_ms": 150
}
```

## Error Handling

The system provides comprehensive error handling:

- **Validation Errors**: Invalid tool arguments or missing required fields
- **Tool Errors**: File not found, search failures, API errors
- **System Errors**: Network issues, service unavailability

All errors are returned as observations that the LLM can reason about and potentially recover from.

## Testing

The implementation includes comprehensive tests:

- **Unit Tests**: Individual tool implementations (`*.test.ts`)
- **Integration Tests**: Tool executor and handler functionality
- **Workflow Tests**: Complete ReAct + tool execution flows

Run tests with:
```bash
npm test -- tools/
```

## Adding New Tools

To add a new tool:

1. **Create Tool Implementation**: Add `newTool.ts` with `executeNewTool()` function
2. **Update Tool Executor**: Add case to `executeToolByName()` switch statement
3. **Update Tool Manifest**: Add tool description to `generateToolManifestPrompt()`
4. **Add Validation**: Create validation function for tool arguments
5. **Write Tests**: Add comprehensive unit tests

## Security Considerations

- **Input Validation**: All tool arguments are validated before execution
- **Access Control**: Tools respect project boundaries and user permissions
- **API Key Management**: User API keys are passed through securely
- **Error Sanitization**: Error messages don't leak sensitive information

## Performance Considerations

- **Caching**: Vector search results and file content can be cached
- **Timeouts**: Tool execution has reasonable timeout limits
- **Rate Limiting**: API calls are subject to rate limiting
- **Resource Limits**: File size and search result limits prevent abuse 